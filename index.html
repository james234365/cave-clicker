<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cave Miner</title>
<link rel="icon" type="image/png" href="favicon.png">
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<!-- Social media preview -->
<meta property="og:title" content="Cave Miner Clicker" />
<meta property="og:description" content="Play Cave Miner Clicker online! Collect resources and upgrade your cave!" />
<meta property="og:type" content="website" />
<meta property="og:image" content="https://cave-miner.onrender.com/preview.png" />
<meta property="og:url" content="https://cave-miner.onrender.com/" />

<!-- Optional for Twitter -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Cave Miner Clicker">
<meta name="twitter:description" content="Play Cave Miner Clicker online! Collect resources and upgrade your cave!">
<meta name="twitter:image" content="https://cave-miner.onrender.com/preview.png">

<style>
body {
  margin: 0;
  overflow: hidden;
  font-family: 'Press Start 2P', cursive;
  background: #1a0f09;
  image-rendering: pixelated;
}

/* POP ZOOM effect for the whole screen */
.pop-zoom {
  animation: screenPop 0.25s ease forwards;
}
@keyframes screenPop {
  0% { transform: scale(1); }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); }
}

#game {
  position: relative;
  width: 100vw;
  height: 100vh;
  background: #3b2b22 url('bg.png') center/cover no-repeat;
  overflow: hidden;
  transition: transform 0.15s ease;
}

/* Counter (top center) */
#counter {
  position: absolute;
  top: 10px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  align-items: center;
  gap: 10px;
}

#counter img {
  width: 36px;
  height: 36px;
  image-rendering: pixelated;
}

#count {
  color: #fff;
  font-size: 28px;
}

/* Crystal */
#crystal {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 40vw;
  max-width: 180px;
  transform: translate(-50%, -50%);
  cursor: pointer;
  image-rendering: pixelated;
  transition: transform 0.1s ease;
}

.pop {
  animation: popAnim 0.15s forwards;
}
@keyframes popAnim {
  0% { transform: translate(-50%, -50%) scale(1); }
  50% { transform: translate(-50%, -50%) scale(1.3); }
  100% { transform: translate(-50%, -50%) scale(1); }
}

/* Pickaxe */
#pickaxe {
  position: absolute;
  top: 50%;
  left: 56%;
  width: 35vw;
  max-width: 160px;
  transform-origin: left center;
  transform: translateX(-0%) translateY(-50%) rotate(0deg);
  image-rendering: pixelated;
}

.swing {
  animation: swingMotion 0.25s ease forwards;
}
@keyframes swingMotion {
  0% { transform: translateX(-0%) translateY(-50%) rotate(0deg); }
  40% { transform: translateX(-0%) translateY(-50%) rotate(-90deg); }
  100% { transform: translateX(-0%) translateY(-50%) rotate(0deg); }
}

/* Drop animation (particles when mining) */
.drop {
  position: absolute;
  width: 20vw;
  max-width: 100px;
  height: auto;
  pointer-events: none;
  image-rendering: pixelated;
}

/* Level bar */
#level-bar-container {
  position: absolute;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  width: 80%;
  max-width: 400px;
  height: 12px;
  background: #2b1a3a;
  border: 2px solid #1a0f24;
  image-rendering: pixelated;
}

#level-bar {
  width: 0%;
  height: 100%;
  background: #8a2be2;
  image-rendering: pixelated;
}

/* Level counter (bottom) */
#level-counter {
  position: absolute;
  bottom: 36px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  align-items: center;
  gap: 6px;
  color: white;
  font-size: 14px;
}

#level-counter img {
  width: 18px;
  height: 18px;
}

/* Goblin Buy Button */
#gob-button {
  position: absolute;
  top: 50%;
  left: 25%;
  transform: translate(-50%, -50%);
  width: 150px;
  height: 150px;
  cursor: pointer;
  image-rendering: pixelated;
  z-index: 10;
}

/* Goblins */
.goblin {
  position: absolute;
  width: 240px;
  height: 240px;
  image-rendering: pixelated;
  pointer-events: none;
  transform-origin: bottom center;
  transition: transform 0.2s ease;
  z-index: 2;
}

/* Skeletons */
.skeleton {
  position: absolute;
  width: 240px;
  height: 240px;
  image-rendering: pixelated;
  pointer-events: none;
  transform-origin: bottom center;
  z-index: 1;
}

/* Drop multiplier (under crystal) */
#drop-display {
  position: absolute;
  top: 72%; /* adjust under the crystal */
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  align-items: center;
  gap: 6px;
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
  z-index: 20;
}

#drop-display.show {
  opacity: 1;
}

#drop-display img {
  width: 36px;   /* same as top counter drop */
  height: 36px;
  image-rendering: pixelated;
}

#drop-multiplier {
  font-family: 'Press Start 2P', monospace;
  font-size: 18px;
  color: #fff;
  text-shadow: 2px 2px 4px #000;
}
/* Drop multiplier pop */
.pop-zoom-drop {
  animation: popZoomDrop 0.25s ease forwards;
}
@keyframes popZoomDrop {
  0%   { transform: translateX(-50%) scale(1); }
  50%  { transform: translateX(-50%) scale(1.3); }
  100% { transform: translateX(-50%) scale(1); }
}

#sound-btn {
  position: absolute;
  top: 10px;
  right: 10px;
  width: 84px; /* doubled from 42px */
  height: 84px; /* doubled from 42px */
  cursor: pointer;
  image-rendering: pixelated;
  transition: transform 0.2s ease, filter 0.3s ease;
  z-index: 20;
  transform-origin: top right; /* keeps it anchored to top-right corner */
}

#sound-btn:hover {
  transform: scale(1.1); /* still slightly bigger on hover */
  filter: brightness(1.2);
}

#sound-btn.muted {
  filter: brightness(1.2);
}

/* === RESET BUTTON === */
#reset-btn {
  position: absolute;
  top: 10px;
  left: 10px;
  width: 84px; /* doubled from 42px */
  height: 84px; /* doubled */
  cursor: pointer;
  image-rendering: pixelated;
  transition: transform 0.2s ease, filter 0.3s ease;
  z-index: 20;
}

#reset-btn:hover {
  transform: scale(1.1);
  filter: brightness(1.2);
}

/* === RESET OVERLAY === */
#reset-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.7);
  backdrop-filter: blur(6px);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.reset-box h1 {
  font-size: 22px;
  margin-bottom: 30px;
  color: #fff;
  font-weight: bold;
}

/* === RESET BUTTONS === */
.reset-buttons {
  display: flex;
  justify-content: center; /* ⬅ centers horizontally */
  align-items: center;     /* ⬅ centers vertically in the row */
  gap: 40px;               /* ⬅ space between YES and NO */
}

.reset-buttons button {
  background: none;
  border: none;
  outline: none;
  color: white;
  font-family: inherit;
  font-size: 16px;
  font-weight: bold;
  padding: 12px 24px;
  cursor: pointer;
  transition: all 0.2s ease;
}

#reset-yes {
  color: red;
}

.reset-buttons button:hover {
  transform: scale(1.15);
  filter: brightness(1.3);
}

@keyframes popIn {
  from { transform: scale(0.8); opacity: 0; }
  to { transform: scale(1); opacity: 1; }
}

</style>
</head>
<body>
<div id="game">
  <!-- Main counter -->
  <div id="counter">
    <img src="drop.png" alt="drop">
    <span id="count">0</span>
  </div>

  <!-- Crystal and pickaxe -->
  <img id="crystal" src="crystal.png" alt="crystal">
  <img id="pickaxe" src="pickaxe1.png" alt="pickaxe">

  <!-- Level bar -->
  <div id="level-bar-container">
    <div id="level-bar"></div>
  </div>

  <!-- Level counter -->
  <div id="level-counter">
    <img src="drop.png" alt="drop">
    <span id="level-text">0/100</span>
  </div>

  <!-- Goblin buy button -->
  <img id="gob-button" src="bt.png" alt="buy goblin">

  <!-- Sound toggle button -->
<img id="sound-btn" src="sb.png" alt="sound" title="Toggle Sound">

<img id="reset-btn" src="res.png" alt="Reset">
<div id="reset-overlay">
  <div class="reset-box">
    <h1>U REALLY WANNA RESTART?</h1>
    <div class="reset-buttons">
      <button id="reset-yes">YES</button>
      <button id="reset-no">NO</button>
    </div>
  </div>
</div>


  <!-- Audio -->
  <audio id="bgm" src="loop.mp3" loop></audio>
  <audio id="hit" src="hit.mp3"></audio>
  <audio id="buy-sound" src="bt.mp3"></audio>
</div>

<!-- Drop counter -->
<div id="drop-display">
  <img id="drop-img" src="drop.png" alt="drop">
  <span id="drop-multiplier">x1</span>
</div>

<script>
const crystal = document.getElementById('crystal');
const pickaxe = document.getElementById('pickaxe');
const countDisplay = document.getElementById('count');
const hitSound = document.getElementById('hit');
const bgm = document.getElementById('bgm');
const game = document.getElementById('game');
const gobButton = document.getElementById('gob-button');
const levelBar = document.getElementById('level-bar');
const levelText = document.getElementById('level-text');
const buySound = document.getElementById('buy-sound');
const soundBtn = document.getElementById('sound-btn');

let isMuted = false;
let count = 0;
let currentLevel = 0;
let goblins = [];
let skeletons = [];

const MAX_GOBLINS = 20;

// === SETTINGS ===
const pickaxeLevels = [
  { threshold: 0, img: 'pickaxe1.png', power: 1 },
  { threshold: 100, img: 'pickaxe2.png', power: 2 },
  { threshold: 500, img: 'pickaxe3.png', power: 5 },
  { threshold: 1000, img: 'pickaxe4.png', power: 10 },
  { threshold: 5000, img: 'pickaxe5.png', power: 25 },
  { threshold: 10000, img: 'pickaxe6.png', power: 50 },
  { threshold: 50000, img: 'pickaxe7.png', power: 100 },
  { threshold: 100000, img: 'pickaxe8.png', power: 250 },
  { threshold: 1000000, img: 'pickaxe9.png', power: 1000 }
];

const goblinTypes = [
  { img: 'sp1.png', cost: 50, interval: 1000, power: 1 }
];

// === SOUNDS ===
const gobSounds = [ new Audio('gob1.mp3'), new Audio('gob2.mp3') ];
const attackSound = new Audio('attack.mp3');

soundBtn.addEventListener('click', () => {
  isMuted = !isMuted;
  soundBtn.classList.toggle('muted', isMuted);
  soundBtn.src = isMuted ? 'sb_off.png' : 'sb.png';
  [bgm, hitSound, buySound, ...gobSounds, attackSound].forEach(snd => {
    snd.muted = isMuted;
  });
  soundBtn.classList.add('pop-zoom-drop');
  setTimeout(() => soundBtn.classList.remove('pop-zoom-drop'), 250);
});

bgm.volume = Math.min(1, bgm.volume * 1.7);
document.body.addEventListener('click', () => bgm.play().catch(() => {}), { once: true });

// === DROP COUNTER ===
let dropCount = 0;
let dropTimer = null;
function showDropCounter() {
  const dropDisplay = document.getElementById('drop-display');
  const dropMultiplier = dropDisplay.querySelector('#drop-multiplier');
  dropCount++;
  dropMultiplier.textContent = `x${dropCount}`;
  dropDisplay.classList.add('show', 'pop-zoom-drop');
  setTimeout(() => dropDisplay.classList.remove('pop-zoom-drop'), 250);
  if (dropTimer) clearTimeout(dropTimer);
  dropTimer = setTimeout(() => {
    dropDisplay.classList.remove('show');
    dropCount = 0;
  }, 670);
}

// === MINE ===
function mine(powerOverride, isPlayer = false) {
  const power = powerOverride || pickaxeLevels[currentLevel].power;
  count += power;
  countDisplay.textContent = count;

  if (isPlayer) {
    showDropCounter();
    hitSound.currentTime = 0;
    hitSound.play().catch(() => {});
    pickaxe.classList.add('swing');
    crystal.classList.add('pop');
    game.classList.add('pop-zoom');
    setTimeout(() => pickaxe.classList.remove('swing'), 250);
    setTimeout(() => crystal.classList.remove('pop'), 250);
    setTimeout(() => game.classList.remove('pop-zoom'), 250);
  }

  for (let i = pickaxeLevels.length - 1; i >= 0; i--) {
    if (count >= pickaxeLevels[i].threshold) {
      currentLevel = i;
      pickaxe.src = pickaxeLevels[i].img;
      break;
    }
  }

  const nextThreshold = pickaxeLevels[currentLevel + 1]?.threshold || 10000;
  const progress = (count - pickaxeLevels[currentLevel].threshold) /
    (nextThreshold - pickaxeLevels[currentLevel].threshold);
  levelBar.style.width = Math.min(progress * 100, 100) + '%';
  levelText.textContent = `${count}/${nextThreshold}`;
}

// === GOBLIN ASSIGNMENT ===
function assignGoblinToSkeleton() {
  if (goblins.length === 0 || skeletons.length === 0) return;
  const gobObj = goblins.shift();
  const gob = gobObj.element;
  clearInterval(gobObj.interval);

  const target = skeletons.shift();
  if (!target) return;

  gob.src = 'sp2.png';
  const rect = target.getBoundingClientRect();
  gob.style.transition = 'left 1s linear, top 1s linear';
  gob.style.left = rect.left + 'px';
  gob.style.top = rect.top + 'px';

  setTimeout(() => {
    if (game.contains(target)) game.removeChild(target);
    attackSound.currentTime = 0;
    attackSound.volume = 0.6;
    attackSound.play().catch(() => {});
    gob.remove();
    count += 60;
    countDisplay.textContent = count;
    if (skeletons.length > 0 && goblins.length > 0) assignGoblinToSkeleton();
  }, 1200);
}

// === GOBLINS ===
function spawnGoblins(typeIndex, isRestore = false) {
  if (goblins.length >= MAX_GOBLINS) return;

  const type = goblinTypes[typeIndex];
  const spawnOffsetY = 150;

  // ✅ skip cost when loading saved goblins
  if (!isRestore && count < type.cost) return;
  if (!isRestore) {
    count -= type.cost;
    countDisplay.textContent = count;
    buySound.currentTime = 0;
    buySound.play().catch(() => {});
  }

  const gob = document.createElement('img');
  gob.src = type.img;
  gob.className = 'goblin';
  const spawnX = Math.random() * (window.innerWidth - 240);
  const spawnY = window.innerHeight / 2 + spawnOffsetY + (Math.random() * 20 - 10);
  gob.style.left = spawnX + 'px';
  gob.style.top = spawnY + 'px';
  gob.style.transform = spawnX > window.innerWidth / 2 ? 'scaleX(-1)' : 'scaleX(1)';
  game.appendChild(gob);

  const interval = setInterval(() => {
    gob.style.transform = (gob.style.transform.replace(/ scaleY\([^)]+\)/, '') || '') + ' scaleY(1.3)';
    setTimeout(() => {
      gob.style.transform = gob.style.transform.replace(/ scaleY\([^)]+\)/, '');
    }, 200);

    mine(Math.max(1, Math.floor(type.power / 3)), false);

    // Random goblin sound
    if (Math.random() < 0.1) {
      const sound = gobSounds[Math.floor(Math.random() * gobSounds.length)];
      sound.currentTime = 0;
      sound.volume = 0.4;
      sound.play().catch(()=>{});
    }

    if (skeletons.length > 0) assignGoblinToSkeleton();
  }, type.interval);

  goblins.push({ element: gob, interval });
}

// === SKELETONS ===
let skeletonSpawnDelay = 15000;
const MIN_SPAWN = 6000;
const spawnOffsetY = 150;

function spawnSkeleton() {
  const skel = document.createElement('div');
  skel.className = 'skeleton';
  skel.innerHTML = '<img src="skel.png" style="width:100%;height:100%;">';
  const rect = gobButton.getBoundingClientRect();
  const spawnX = rect.left + rect.width / 2 + (Math.random() * 200 - 100);
  const spawnY = window.innerHeight / 2 + spawnOffsetY;
  skel.style.left = spawnX + 'px';
  skel.style.top = spawnY + 'px';
  skeletons.push(skel);
  game.appendChild(skel);
  assignGoblinToSkeleton();
}

function skeletonLoop() {
  if (count >= 120) spawnSkeleton();
  skeletonSpawnDelay = Math.max(MIN_SPAWN, skeletonSpawnDelay * 0.9);
  setTimeout(skeletonLoop, skeletonSpawnDelay);
}
skeletonLoop();

// === SAVE / LOAD ===
function saveGame() {
  const saveData = {
    count,
    currentLevel,
    goblins: goblins.length
  };
  localStorage.setItem('crystalMinerSave', JSON.stringify(saveData));
  console.log("Game saved:", saveData);
}

function loadGame() {
  const saved = localStorage.getItem('crystalMinerSave');
  if (!saved) return;
  const data = JSON.parse(saved);
  count = data.count || 0;
  currentLevel = data.currentLevel || 0;
  countDisplay.textContent = count;
  pickaxe.src = pickaxeLevels[currentLevel].img;

  // ✅ restore goblins
  for (let i = 0; i < (data.goblins || 0); i++) {
    spawnGoblins(0, true);
  }

  console.log("Game loaded:", data);
}

setInterval(saveGame, 5000);
window.addEventListener('load', loadGame);

// === EVENTS ===
crystal.addEventListener('click', () => mine(undefined, true));
gobButton.addEventListener('click', () => spawnGoblins(0));

// === RESET BUTTON ===
const resetBtn = document.getElementById('reset-btn');
const resetOverlay = document.getElementById('reset-overlay');
const resetYes = document.getElementById('reset-yes');
const resetNo = document.getElementById('reset-no');

resetBtn.addEventListener('click', () => {
  resetOverlay.style.display = 'flex';
});

resetNo.addEventListener('click', () => {
  resetOverlay.style.display = 'none';
});

resetYes.addEventListener('click', () => {
  localStorage.removeItem('crystalMinerSave');
  location.reload();
});

</script>

</body>
</html>
